<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://lambdafunk.com/' rel='self' type='application/rss+xml'/>
<title>
Lambda Funk
</title>
<link>
http://lambdafunk.com/
</link>
<description>
Programming, mostly
</description>
<lastBuildDate>
Thu, 02 Feb 2017 12:07:53 -0500
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://lambdafunk.com/posts-output/2016-02-01-Clojure-The-Fun-Parts/
</guid>
<link>
http://lambdafunk.com/posts-output/2016-02-01-Clojure-The-Fun-Parts/
</link>
<title>
Clojure: The Fun Parts
</title>
<description>
&lt;p&gt;Clojure, the fun parts.&lt;/p&gt;&lt;p&gt;Why this tutorial? As the title of the most famous clojure book, (The Joy of Clojure)[http://www.amazon.com/The-Joy-Clojure-Michael-Fogus/dp/1617291412/], states. The Clojure programming language can and does bring joy. It is one of the few languages that has causes me to smile not only because of what I create, but also how I create it. However, often this joy doesn't come until you have invested much time in the languages. So here are the fun parts.&lt;/p&gt;&lt;p&gt;We need to cover just a bit of clojure before we begin. This is a hash-map {:a 2} This is a vector [1 2 3] parenthesis go on the outside in Clojure (+ 1 2)&lt;/p&gt;&lt;p&gt;(nth (filter prime? (range) 9)&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse hidden&quot;&gt; &lt;pre&gt;&lt;code&gt;&amp;#40;def dom &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;defn render! &amp;#91;content&amp;#93;
  &amp;#40;let &amp;#91;content &amp;#40;if &amp;#40;seq? content&amp;#41; &amp;#40;apply str content&amp;#41; content&amp;#41;
        container 
        &amp;#40;aget &amp;#40;.getElementsByClassName js/document &amp;quot;render&amp;quot;&amp;#41; @dom&amp;#41;&amp;#93;
    &amp;#40;aset container &amp;quot;innerHTML&amp;quot; content&amp;#41;&amp;#41;
  content&amp;#41;
&amp;#40;defn dot &amp;#91;x&amp;#93; &amp;#40;str 
&amp;quot;&amp;lt;div style='width:&amp;quot; x &amp;quot;px;&amp;quot;
            &amp;quot;height:&amp;quot; x  &amp;quot;px;&amp;quot;
            &amp;quot;background-color: red;&amp;quot;
            &amp;quot;float: left;&amp;quot;
            &amp;quot;pad &lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;            &amp;quot;'&amp;gt;&amp;quot; &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;quot;&amp;lt;/div&amp;gt;&amp;quot;&amp;#41;&amp;#41;
&amp;#40;defn render-dots &amp;#91;dots&amp;#93;
  &amp;#40;render! &amp;#40;map dot dots&amp;#41;&amp;#41;
  dots&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;render&quot;&gt;&lt;/div&gt;&lt;p&gt;&lt;div data-preamble=&quot;(reset! dom 1)&quot; class=&quot;language-klipse&quot;&gt; &lt;pre&gt;&lt;code&gt;&amp;#40;defn prime? &amp;#91;n&amp;#93; &amp;#40;not-any? #&amp;#40;= &amp;#40;mod n %&amp;#41; 0&amp;#41; &amp;#40;range 2 n&amp;#41;&amp;#41;&amp;#41;
&amp;#40;filter prime? &amp;#40;range 10 40&amp;#41;&amp;#41;
&amp;#40;render-dots &amp;#40;range 20&amp;#41;&amp;#41; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt; &lt;div class=&quot;render&quot;&gt;&lt;/div&gt;&lt;/p&gt;&lt;p&gt;(prime?  This is already a pretty great approach to defining a prime, but lets see what we can do composing something like this.&lt;/p&gt;&lt;p&gt;(defn nth-prime [n]  (nth (filter prime? (range)) n))&lt;/p&gt;&lt;p&gt;(sum (map nth-prime (range 5))) (sum (take 5 (filter prime? (range)))) (sum (take 5 primes))&lt;/p&gt;&lt;p&gt;When choosing tools or frameworks you are rarely getting a huge leap in solving small problems. It is the avoidance of technical debt that should be sought. A problem may be only slightly more difficult to reason about, but it is the combination of reasoning about multiple parts of your system which becomes complex.&lt;/p&gt;&lt;p&gt;(defn prime? [n] (not-any? #(= (mod n %) 0) (range 2 n)) (defn prime? [n] (not-any? #(= (mod n %) 0) (filter prime? (range 2 n))))&lt;/p&gt;&lt;p&gt;(declare prime?) (def primes    (filter &lt;pre&gt;&lt;code&gt;&amp;#40;fn &amp;#91;n&amp;#93; &amp;#40;not-any? #&amp;#40;= &amp;#40;mod n %&amp;#41; 0&amp;#41; &amp;#40;drop 2 primes&amp;#41;&amp;#41;&amp;#41; 
&amp;#40;range&amp;#41;&amp;#41;&amp;#41; &lt;/code&gt;&lt;/pre&gt;(defn prime? [n] (not-any? #(= (mod n %) 0) (drop 2 primes))) (defn prime? [n] (not-any? #(= (mod n %) 0) pri es)) &lt;/p&gt;&lt;p&gt;Lets wrap it all up by combining macros(destructuring) (functional programming), First-class interop.&lt;/p&gt;&lt;p&gt;(doseq [[x y] (map (juxt identity **) (take n (range)))]   (if (prime? x)&lt;pre&gt;&lt;code&gt;&amp;#40;draw-point! &amp;#91;x y&amp;#93; &amp;quot;blue&amp;quot;&amp;#41;
&amp;#40;draw-point! &amp;#91;x y&amp;#93; &amp;quot;red&amp;quot;&amp;#41;&amp;#41;&amp;#41; &lt;/code&gt;&lt;/pre&gt;Macros. Destructuring We introduce the concept of let. (let [a 3]  (+ a 7)) ; 10&lt;/p&gt;&lt;p&gt;This is just a way to provide variable scoping. It may looks simple, but therein lies its power. This is a trend in Clojure. Many simple pieces come together to form powerful abstractions.&lt;/p&gt;&lt;p&gt;Now that we know let we can move on to the next step destructuring. (let &lt;a href=''&gt;[a b&lt;/a&gt;]   [a b (+ a b)]) ; [4 5 9]&lt;/p&gt;&lt;p&gt;Returns a vector of a a,b, and a+b. Pretty simple, but it introduces the idea of destructuring. With a simple sytnax we can very easily build and take apart groups of data.&lt;/p&gt;&lt;p&gt;Here is another neat feature of destructuring. We can deal with infinite and optional arguments, which works great combined with inifite, lazy sequences.&lt;/p&gt;&lt;p&gt;(let [[first second &amp; more] (range)]   second)&lt;/p&gt;&lt;p&gt;Destrucuturing isn't limited to just lets, we can use it in function arguments as well. We can also combine the techniques above and introduce a feature for destructuring optional hash arguments.  Here we'll write a function to generate the html for a square div. Using (hiccup)[http://github.com/weavejester/hiccup] to change our data structures into html.&lt;/p&gt;&lt;p&gt;(defn square [width &amp; {:keys [[x y] :as pos] color]}]   (html [:div {:style {:position &quot;absolute&quot;&lt;pre&gt;&lt;code&gt;                   :top &amp;#40;or x 0&amp;#41; :left &amp;#40;or y 0&amp;#41;
                   :width width :height width 
                   :background-color &amp;#40;or color &amp;quot;blue&amp;quot;&amp;#41;}&amp;#93;&amp;#41;&amp;#41; &lt;/code&gt;&lt;/pre&gt;We can call this function with expected results in many differnt ways. ; We just the necessary arguments (square 200 200) ; With a color (square 200 200 :color &quot;blue&quot;) ; Or a position (square 200 200 :pos [500 400]) ; Or both (square 200 200 :color &quot;red :pos [20 20]) ;Or change the order of our map. (square 200 200 :pos [20 20] :color &quot;red)&lt;/p&gt;&lt;p&gt;We are also provided with nesting. Which lets us pick apart something like a grid and do (determinants)[http://www.purplemath.com/modules/determs.htm] of a 2x2 matrix.&lt;/p&gt;&lt;p&gt;(let &lt;a href=''&gt;[[a b&lt;/a&gt;] [[11 12] &lt;pre&gt;&lt;code&gt;                 &amp;#91;21 22&amp;#93;&amp;#93;&amp;#93; &lt;/code&gt;&lt;/pre&gt;  (- (&lt;em&gt; a d) (&lt;/em&gt; c b)))&lt;/p&gt;&lt;p&gt;What follows from this is that we can take these ideas and combined them along with some others features which also allow &lt;/p&gt;&lt;p&gt;We are going to add one last tweak here to show off the the beauty of if being a macro and not a piece of language syntax.&lt;/p&gt;&lt;p&gt;In an imperative language we would have our if setting a color variable like so. &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;if&amp;#40;x.isPrime?&amp;#40;&amp;#41;&amp;#41; {
  color = &amp;quot;blue&amp;quot;
} else {
 color = &amp;quot;red&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead we are using if to decide which command to execute. If we look closer what we are actually doing is using if to decide which block of code should be passed back up to doseq which will then execute it. So if we look at if this we realize it is composable just like the functions we have written. So let's treat it as such.&lt;/p&gt;&lt;p&gt;(doseq [[x y] (map (juxt identity **) (take n (range)))]&lt;pre&gt;&lt;code&gt;&amp;#40;draw-point! &amp;#91;x y&amp;#93; &amp;#40;if &amp;#40;prime? x&amp;#41; &amp;quot;red&amp;quot; &amp;quot;blue&amp;quot;&amp;#41;&amp;#41;&amp;#41; &lt;/code&gt;&lt;/pre&gt;(defn draw-graph [points]   (doseq [[x y] points]&lt;pre&gt;&lt;code&gt;&amp;#40;draw-point! x y &amp;#40;if &amp;#40;prime? x&amp;#41; &amp;quot;red&amp;quot; &amp;quot;blue&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#41; &lt;/code&gt;&lt;/pre&gt;(defn draw-graph [ (doseq [x (map(range n)]   (draw-point! [x (js-func x)] (if prime? x) &quot;red&quot; &quot;blue&quot;))&lt;/p&gt;&lt;p&gt;Now our if code is deciding which block of code to pass back up to the draw-point function, the blocks of code in this case are just strings. draw-point accepts these strings and simply uses them as a color argument. The explanation way be a bit wordy, but the code itself is very simple and quite obvious.&lt;/p&gt;    &lt;br /&gt;&lt;p&gt;(doseq [[x y] (map (juxt identity **) (take n (range)))]   (if (prime? x)&lt;pre&gt;&lt;code&gt;&amp;#40;draw-point! &amp;#91;x y&amp;#93; &amp;quot;blue&amp;quot;&amp;#41;
&amp;#40;draw-point! &amp;#91;x y&amp;#93; &amp;quot;red&amp;quot;&amp;#41;&amp;#41;&amp;#41; &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;The exclamation point just means there are side effects.&lt;/p&gt;&lt;p&gt;On core.async and local event loops&lt;/p&gt;&lt;pre&gt;&lt;code&gt;         &amp;#40;print dialogue&amp;#41;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;         Declarating state change graphics.
         We store a list of states as render as a point in the transition.
         It is how to describe a state rather than describing a process.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://app.klipse.tech/css/codemirror.css&quot;&gt; &lt;/link&gt;&lt;/p&gt;&lt;p&gt;&lt;script&gt; window.klipse_settings = { selector: &quot;.language-klipse&quot; }; &lt;/script&gt; &lt;script src=&quot;http://app.klipse.tech/plugin/js/klipse_plugin.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;&lt;h2&gt;Footnotes&lt;/h2&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Mon, 01 Feb 2016 00:00:00 -0500
</pubDate>
</item>
<item>
<guid>
http://lambdafunk.com/posts-output/2016-01-31-why-clojure/
</guid>
<link>
http://lambdafunk.com/posts-output/2016-01-31-why-clojure/
</link>
<title>
Why Clojure?
</title>
<description>
&lt;p&gt;The first half-decade of my programming career I was obsessed with trying new programming languages. I couldn't read a post on Hacker News without taking the language for a spin and building some small test project with it. I wanted desperately to master a programming language, yet every new language seemed so much better than the last one. After the recommendation of a good friend and an incredible &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy'&gt;presentation&lt;/a&gt; I started using Clojure and I've begun to use it increasingly more. Since then, I've stumbled across and tried some &lt;a href='http://witheve.com'&gt;amazing&lt;/a&gt; &lt;a href='http://elm-lang.org'&gt;programming&lt;/a&gt; &lt;a href='http://haskell.org'&gt;langauges&lt;/a&gt;, but nothing has managed to move my focus away from Clojure. I've written tons of side projects with it, used it professionally for a year and just released a small &lt;a href='https://play.google.com/store/apps/details?id=com.linguis.cards&amp;hl=en'&gt;app&lt;/a&gt; written in it. Clojure grabbed my attention, but unlike many other languages it has continued to do so. Stopping to reflect I noticed, without ever intending to, I have become a Clojure programmer. &quot;Why Clojure?&quot; is not the beginning of a sales pitch, but a question to myself. Why do I enjoy this language so much?&lt;/p&gt;&lt;h2&gt;Realistically Functional&lt;/h2&gt;&lt;p&gt;An important and difficult part of software development is creating consistent software. In Mathematics, functions are pure. A pure function is deterministic which means it is consistent by definition. So if we use values and functions, the problem of consistency disappears. Functional programming takes advantage of this and provides tools for working with concrete immutable values. Fortunately for humanity, and unfortunately for software developers, the world doesn't have a set value, it has state. If our software is going to do something useful, it has to interact with the world. So if our program is going to do something useful, it has to have state.&lt;/p&gt;&lt;p&gt;Object oriented programming does a great job of providing ways to manage this state and this is part of why it has become so popular. Complex object models can be used to represent that state inside of our program. However, with these models of state comes their complexity. Objects tie together behaviors(methods) with state. Connections between things grow at an exponential rate, ala the &lt;a href='http://mathworld.wolfram.com/HandshakeProblem.html'&gt;handshake problem&lt;/a&gt;. The larger the system becomes the more complex it becomes, and each additional relationships adds exponentially more complexity. Anyone who has worked with sufficiently large software has seen this problem first hand. An increasingly complex system becomes increasingly more difficult to understand. The system becomes increasingly more difficult to modify, fix, or imprvome.&lt;/p&gt;&lt;p&gt;In Clojure data is immutable by default, utilizing the purity of stateless functions to avoid the problems of compleity introduced by state.  However, it still acknowledges the benefits and necessity of state by providing well-defined method for handling mutable &lt;a href='https://clojure.org/about/state'&gt;identities&lt;/a&gt;. Providing constructs that make the manipulation of state explicit. As a result, state is something I rarely think about while programming in Clojure, but is readily available when needed. The majority of a Clojure program can be written as functions accepting and returning values. The separation of behavior from state means when working with the logic of a system you do not have to hold the state of that system in your head. When programming a function in Clojure I am only working on the function and the values passed into it. This style of programming took some time to get used to but once I did, it was incredibly freeing. Gone are the days of tracking down bugs caused by some complicated relationship between every changing entities. No more worrying about the effects of simple changes that may ripple through a complicated system.&lt;/p&gt;&lt;h2&gt;A Modern Lisp&lt;/h2&gt;&lt;p&gt;Clojure belongs to a family of languages called &lt;a href='https://en.wikipedia.org/wiki/Lisp_&amp;#40;programming_language&amp;#41;'&gt;Lisp&lt;/a&gt;. Lisp receives a lot of love and hate in the programming community and most of the criticism of Lisp is levied at its syntax. The amount of time we spend reading code as programmers makes syntax an important part of a programming language. Clojure solves some of the problems with traditional Lisp by implementing enough syntactic improvement to make writing and reading Clojure code mode quicker, compared to traditional Lisps. &lt;/p&gt;&lt;p&gt;As a Lisp, Clojure source code is written as a data structure. Traditional Lisps have been designed entirely around the list data structure, providing a very limited syntax for writing code. Clojure has expanded its support for collections, notably: sets, vectors, and maps. Along with providing additional syntax for creating these types. This produces more readable code than previous Lisps, while still providing the property of homoiconicity, which forms the basis of the incredibly powerful macro system in Lisp languages.&lt;/p&gt;&lt;p&gt;Due to Clojure's homoiconicity, or code as data. When writing a macro in Clojure you are writing a function accepting code, and since this code is data, you can treat it the same way you would any other data. This means you have the full power of the language at your disposal. Understanding just how powerful this simple concept is can be difficult without experience. It is often said there is an &lt;a href='http://www.catb.org/esr/faqs/hacker-howto.html'&gt;&quot;aha moment&quot;&lt;/a&gt; when one fully understands the power of Lisp macros. For me, that &quot;aha moment&quot; came with the release of the Clojure core library &lt;a href='https://github.com/clojure/core.async'&gt;core.async&lt;/a&gt;. The core.async library is an implementation of CSP style channels as a core library. Powerful concurrency tools and syntax implemented not as a language feature, but as separate library composed of standard Clojure code. New libraries with features just as powerful are consistently released relying on the power of macros including tools such as &lt;a href='http://github.com/clojure/core.match'&gt;pattern matching&lt;/a&gt;, &lt;a href='http://github.com/clojure/core.logic'&gt;logic programming&lt;/a&gt;, and a &lt;a href='http://github.com/clojure/core.typed'&gt;type system&lt;/a&gt;. Tools like these along with the macros you write in your own code make writing code that is understandable much simpler. &lt;/p&gt;&lt;h2&gt;Excellent Direction&lt;/h2&gt;&lt;p&gt;&lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy'&gt;Simple Made Easy&lt;/a&gt;, the greatest talk I have seen given on programming gives insight into the design process of Clojure as a language. &quot;You can write a sophisticated a system with dramatically simpler tools, which means you're going to be focusing on the system, what it's supposed to do, instead of all the gook that falls out of the constructs you're using.&quot; This quote from the talk highlights the philosophy of Clojure as a language. Programming is about solving difficult problems. Focusing on tools that make something easier, often make the tradeoff of introducing complexity. This complexity grows and grows until we spend more time solving problems created by the complexity than we spend solving the problem itself. Clojure is designed with simplicity as a goal and the more time I spend programming in Clojure the more I realize the value of simplicity. Each feature in Clojure is added to the power of clojure as a tool, while mantaining this clear focus on simplicity.&lt;/p&gt;&lt;p&gt;During its development Clojure has consisntently taken ideas from the development of languages and tools coming before it. Taking a piecemeal approach by borrowing the good parts and leaving the unnecessary behind. Lisp's hygienic macros, running on the JVM, CSP style channels and the latest Clojure feature &lt;a href='https://clojure.org/about/spec'&gt;core.spec&lt;/a&gt;.spec, are all examples of this approach. core.spec is a great example of improving on great ideas of others. It provides a lot of the tools of a type system and is very similar, but is implemented in a way that fits Clojure's simplicity and flexibility as a dynamic language providing validation, error reporting, parsing, instrumentation, documentation, and generative testing. And the language itself is not the only part of Clojure embracing change. The Clojure community itself is frequently tossing out old assumptions about how we should program. Developing libraries with novel and useful approaches to old problems. From &lt;a href='https://github.com/cgrand/enlive'&gt;templating&lt;/a&gt; to &lt;a href='http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs'&gt;UI-rendering&lt;/a&gt; Clojure embraces change. Based on a 50 year old language, from the start Clojure has been molded by the tools before, but has shown no sign of clinging to the past.&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;10 years ago, when I started programming, the discussion of programming had more to do with which object system was best. Discussion about language paradigms was something often left to academics. Even startups, moving fast and considered brave, were busy deciding which &lt;a href='http://ruby-lang.org'&gt;dynamic&lt;/a&gt; &lt;a href='http://python.org'&gt;langauge&lt;/a&gt; was more &lt;a href='http://php.net'&gt;hip&lt;/a&gt;. Criticizing object oriented programming was considered brave and talking about functional programming was something unique. So quickly  the discussion has broadened, not just in the Clojure community, but in the programming community at large. People aren't just solving problems, but are thinking deeply about the tools we use to do so. There is a growing trends of not just relying on our tools, but also on our minds. Which leads to the answer for &quot;Why Clojure?&quot;. Because the more I program in Clojure the less time I spend at the keyboard and the more time I spend thinking. With thought as the most powerful tool available, the result is I'm writing better software, but more importantly, I'm having more fun.
</description>
<enclosure>

</enclosure>
<pubDate>
Sun, 31 Jan 2016 00:00:00 -0500
</pubDate>
</item>
</channel>
</rss>
