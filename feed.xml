<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://lambdafunk.com/' rel='self' type='application/rss+xml'/>
<title>
Lambda Funk
</title>
<link>
http://lambdafunk.com/
</link>
<description>
Programming, mostly
</description>
<lastBuildDate>
Wed, 01 Mar 2017 14:55:34 -0500
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://lambdafunk.com/2017-02-21-Interpolating-Polygons/
</guid>
<link>
http://lambdafunk.com/2017-02-21-Interpolating-Polygons/
</link>
<title>
Interpolating Polygons
</title>
<description>
&lt;p&gt;&lt;strong&gt;Code samples are live and edibtable enabled by &lt;a href='http://github.com/viebel/klipse'&gt;Klipse&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;In writing a library for animation I stumbled upon the problem of how to animate polygons. Trying to create animations like this:&lt;/p&gt;&lt;p&gt;&lt;canvas width=&quot;200&quot; height=&quot;200&quot; id=&quot;canvas-0&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Generating an animation given an initial and final value relies on &lt;a href='http://en.wikipedia.org/wiki/Interpolation'&gt;interpolation&lt;/a&gt; to find the intermediary values. Interpolation is simple when working with simple values like numbers, but becomes more complex as the data being interpolated becomes more complex. Polygons contain some features which make interpolating them a little interesting.&lt;/p&gt;&lt;p&gt;&lt;pre style=&quot;display:none&quot;&gt; &lt;div class=&quot;language-klipse&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def canvas &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;defn get-canvas &amp;#91;id&amp;#93;
  &amp;#40;js/document.getElementById &amp;#40;str &amp;quot;canvas-&amp;quot; id&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn clear-canvas! &amp;#91;canvas-id&amp;#93;
  &amp;#40;let &amp;#91;canvas &amp;#40;get-canvas canvas-id&amp;#41;
        context &amp;#40;.getContext canvas &amp;quot;2d&amp;quot;&amp;#41;&amp;#93;
    &amp;#40;.clearRect context 0 0 &amp;#40;.-width canvas&amp;#41; 
                            &amp;#40;.-height canvas&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn reset-canvas! &amp;#91;canvas-id&amp;#93;
  &amp;#40;reset! canvas canvas-id&amp;#41;
  &amp;#40;clear-canvas! canvas-id&amp;#41;&amp;#41;

&amp;#40;defn render-polygon! 
 &amp;#40;&amp;#91;polygon&amp;#93; &amp;#40;render-polygon! @canvas polygon {}&amp;#41;&amp;#41;
 &amp;#40;&amp;#91;polygon opts&amp;#93; &amp;#40;render-polygon! @canvas polygon opts&amp;#41;&amp;#41;
 &amp;#40;&amp;#91;canvas-id polygon {:keys &amp;#91;color&amp;#93; :or {color &amp;quot;blue&amp;quot;}}&amp;#93;
  &amp;#40;let &amp;#91;canvas &amp;#40;get-canvas canvas-id&amp;#41;
        &amp;#91;&amp;#91;initial-x initial-y&amp;#93; &amp;amp; rest&amp;#93; polygon
        context &amp;#40;.getContext canvas &amp;quot;2d&amp;quot;&amp;#41;&amp;#93;
        &amp;#40;doto context
          &amp;#40;aset &amp;quot;fillStyle&amp;quot; color&amp;#41;
          &amp;#40;.beginPath&amp;#41;
          &amp;#40;.moveTo context initial-x initial-y&amp;#41;&amp;#41;
        &amp;#40;doseq &amp;#91;&amp;#91;x y&amp;#93; rest&amp;#93;
          &amp;#40;.lineTo context x y&amp;#41;&amp;#41;
        &amp;#40;doto context
          &amp;#40;.lineTo initial-x initial-y&amp;#41;
          &amp;#40;.fill&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def animation-duration 1000&amp;#41;
&amp;#40;def pre-pause 500&amp;#41;
&amp;#40;def post-pause 500&amp;#41;

&amp;#40;defn get-time &amp;#91;&amp;#93; &amp;#40;js/Date.now&amp;#41;&amp;#41;

&amp;#40;def animations &amp;#40;atom {}&amp;#41;&amp;#41;

&amp;#40;defn animate
  &amp;#40;&amp;#91;initial final interpolation-fn&amp;#93; 
    ; Mark animation for canvas 

    &amp;#40;swap! animations assoc @canvas &amp;#91;initial final interpolation-fn&amp;#93;&amp;#41;
    &amp;#40;render-polygon! @canvas &amp;#40;interpolation-fn 0 initial final&amp;#41; {}&amp;#41;
    &amp;#40;animate initial final interpolation-fn &amp;#40;get-time&amp;#41; @canvas&amp;#41;
    initial&amp;#41;
  &amp;#40;&amp;#91;initial final interpolation-fn start-time canvas-id&amp;#93;
    &amp;#40;let &amp;#91;total-time &amp;#40;+ pre-pause post-pause animation-duration&amp;#41;
          p 
          &amp;#40;-&amp;gt; &amp;#40;get-time&amp;#41; &amp;#40;- start-time&amp;#41; 
              &amp;#40;mod total-time&amp;#41;
              &amp;#40;- pre-pause&amp;#41;
              &amp;#40;/ animation-duration&amp;#41;
              &amp;#40;max 0&amp;#41; &amp;#40;min 1&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;clear-canvas! canvas-id&amp;#41;
    &amp;#40;render-polygon! canvas-id &amp;#40;interpolation-fn p initial final&amp;#41; {}&amp;#41;
    ; Do not repeat animation if a new one has been started
    &amp;#40;if &amp;#40;= &amp;#40;get @animations canvas-id&amp;#41; &amp;#91;initial final interpolation-fn&amp;#93;&amp;#41;
      &amp;#40;js/requestAnimationFrame 
        &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;animate initial final interpolation-fn start-time canvas-id&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn to-rect 
  &amp;#40;&amp;#91;&amp;#91;theta radius&amp;#93;&amp;#93; &amp;#40;to-rect &amp;#91;0 0&amp;#93; &amp;#91;theta radius&amp;#93;&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;&amp;#91;x y&amp;#93; &amp;#91;theta radius&amp;#93;&amp;#93;
    &amp;#91;&amp;#40;+ x &amp;#40;&amp;#42; radius &amp;#40;js/Math.cos theta&amp;#41;&amp;#41;&amp;#41;
     &amp;#40;+ y &amp;#40;&amp;#42; radius &amp;#40;js/Math.sin theta&amp;#41;&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn rect 
  &amp;#40;&amp;#91;width height&amp;#93; &amp;#40;rect 0 0 width height&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;x y width height&amp;#93;
    &amp;#91;&amp;#91;x y&amp;#93;          
    &amp;#91;&amp;#40;+ x width&amp;#41; y&amp;#93; 
    &amp;#91;&amp;#40;+ x width&amp;#41; &amp;#40;+ y height&amp;#41;&amp;#93; 
    &amp;#91;x &amp;#40;+ y height&amp;#41;&amp;#93;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn random-polar-polygon &amp;#91;edges radius&amp;#93;
  &amp;#40;let &amp;#91;radius-damper 0.34
        angle-damper  1.22
        angle-increment &amp;#40;/ &amp;#40;&amp;#42; 2 js/Math.PI&amp;#41; edges&amp;#41;&amp;#93;
    &amp;#40;mapv 
      &amp;#40;fn &amp;#91;edge&amp;#93; 
        &amp;#91;&amp;#40;+ &amp;#40;&amp;#42; angle-increment edge&amp;#41; 
            &amp;#40;&amp;#42; &amp;#40;js/Math.pow &amp;#40;rand&amp;#41; angle-damper&amp;#41; angle-increment&amp;#41;&amp;#41;
         &amp;#40;&amp;#42; &amp;#40;js/Math.pow &amp;#40;rand&amp;#41; radius-damper&amp;#41; radius&amp;#41;&amp;#93;&amp;#41;
      &amp;#40;range edges&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn random-polygon 
  &amp;#40;&amp;#91;n&amp;#93; &amp;#40;random-polygon n 100&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;n radius&amp;#93; &amp;#40;random-polygon n &amp;#91;radius radius&amp;#93; radius&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;n center radius&amp;#93; 
    &amp;#40;mapv &amp;#40;partial to-rect center&amp;#41; &amp;#40;random-polar-polygon n radius&amp;#41;&amp;#41;&amp;#41;&amp;#41;

 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;/pre&gt;&lt;/p&gt;&lt;p&gt;An interpolation function will have the arguments &lt;code&gt;initial&lt;/code&gt;, &lt;code&gt;final&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;. Where &lt;code&gt;p&lt;/code&gt; indicates the position of the value being returned. &lt;code&gt;p&lt;/code&gt; is the distance from our intial value of the value being returned. Where &lt;code&gt;p=0&lt;/code&gt; returns the intial value, and &lt;code&gt;p=1&lt;/code&gt; indicates the final value. In mathmatical notation that is: &lt;/p&gt;&lt;p&gt;&lt;code&gt;V = Vinitial&amp;#42;&amp;#40;1-p&amp;#41; + Vfinal&amp;#42;p&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Starting with the simplest case, consisting of two equal sized polygons. The problem can be broken down into interpolating a series of points. Each point can be broken down into interpolating two numbers.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn interpolate-number  &amp;#91;p initial final&amp;#93;
  &amp;#40;+ &amp;#40;&amp;#42; initial &amp;#40;- 1 p&amp;#41;&amp;#41; &amp;#40;&amp;#42; final p&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn interpolate-points &amp;#91;p initial-point final-point&amp;#93;
  &amp;#40;mapv &amp;#40;partial interpolate-number p&amp;#41;
    initial-point final-point&amp;#41;&amp;#41;

&amp;#40;interpolate-points 0.5 &amp;#91;0 0&amp;#93; &amp;#91;10 10&amp;#93;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;Mapping over polygons gives the interpolation function as demonstrated with a quick test using some rectangles.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn interpolate-polygons &amp;#91;p initial final&amp;#93;
  &amp;#40;mapv &amp;#40;partial interpolate-points p&amp;#41; initial final&amp;#41;&amp;#41;

&amp;#40;interpolate-polygons 0.5 &amp;#40;rect 0 0 10 10&amp;#41; &amp;#40;rect 20 0 10 10&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;Along with a rendering to make things more clear. With each polygon as a different color to distinguish them from each other. Notice the polygon is in between the other two by size and position.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset! canvas 4)&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;let &amp;#91;rect-1 &amp;#40;rect 0 0 30 30&amp;#41;
      rect-2 &amp;#40;rect 200 0 60 60&amp;#41;&amp;#93;
&amp;#40;render-polygon! rect-1 {:color &amp;quot;red&amp;quot;}&amp;#41;
&amp;#40;render-polygon! &amp;#40;interpolate-polygons 0.5 rect-1 rect-2&amp;#41; {:color &amp;quot;green&amp;quot;}&amp;#41;
&amp;#40;render-polygon! rect-2 {:color &amp;quot;blue&amp;quot;}&amp;#41;&amp;#41;

 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;50&quot; id=&quot;canvas-4&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Now let's look at this in the context of an animation. The animate function will render interpolated polygons for values &lt;code&gt;p = &amp;#91;0,1&amp;#93;&lt;/code&gt;. &lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 6)&quot; data-eval-idle-msec=&quot;500&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;animate &amp;#40;rect 0 0 100 100&amp;#41; &amp;#40;rect 0 0 200 200&amp;#41; interpolate-polygons&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;200&quot; id=&quot;canvas-6&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Another example making use of a random polygon function written in an &lt;a href='http://lambdafunk.com/posts-output/2016-02-16-Random-Polygons'&gt;earlier blog post&lt;/a&gt;. &lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 7)&quot; data-eval-idle-msec=&quot;500&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;animate &amp;#40;random-polygon 5&amp;#41; &amp;#40;random-polygon 5&amp;#41; interpolate-polygons&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;200&quot; id=&quot;canvas-7&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;As shown, interpolating polygons with the same number of points is straightforward. More interesting is developing a method for polygons of unequal sides. Adding points to the polygon with the lesser points allows reuse of the previous function. As long as the point added to the polygon are added are on the edges it will not change the shape of the original polygon until it becomes animated.&lt;/p&gt;&lt;p&gt;Using a higher-order function we can test this interpolation with a number of different approachs to resizing a polygon. Starting with a very simple approach of copying the last point as many times as needed.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 8)&quot; data-eval-idle-msec=&quot;500&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn fixed-interpolation-fn &amp;#91;resize&amp;#93;
  &amp;#40;fn &amp;#91;p initial final&amp;#93;
    &amp;#40;let &amp;#91;size &amp;#40;max &amp;#40;count initial&amp;#41; &amp;#40;count final&amp;#41;&amp;#41;&amp;#93;
      &amp;#40;interpolate-polygons p 
        &amp;#40;resize initial size&amp;#41; 
        &amp;#40;resize final   size&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn copy-last-point &amp;#91;points n&amp;#93;
  &amp;#40;take n &amp;#40;concat points &amp;#40;repeat &amp;#40;last points&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;animate &amp;#40;random-polygon 7&amp;#41;
         &amp;#40;random-polygon 13&amp;#41;
         &amp;#40;fixed-interpolation-fn copy-last-point&amp;#41;&amp;#41;

 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;250&quot; id=&quot;canvas-8&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;An interesting looking effect, but the points unfurling from one location doesn't have a natural animation feel. What does it look like if we repeat the points circularly and take as many as we need?&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 9)&quot; data-eval-idle-msec=&quot;500&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;
&amp;#40;defn circular-resize &amp;#91;points n&amp;#93;
  &amp;#40;-&amp;gt;&amp;gt; &amp;#40;repeat points&amp;#41;
       &amp;#40;mapcat identity&amp;#41;
       &amp;#40;take n&amp;#41;&amp;#41;&amp;#41;

&amp;#40;animate &amp;#40;random-polygon 5&amp;#41;
         &amp;#40;random-polygon 13&amp;#41;
         &amp;#40;fixed-interpolation-fn circular-resize&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;250&quot; id=&quot;canvas-9&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Even more interesting, it unfurls and crosses inside itself, but it looks even less organic. What's needed is a method to distribute the points across the polygon evenly. This can be done by creating a new polygon and getting the value for each point by accessing the corresponding index of the old polygon.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 10)&quot; data-eval-idle-msec=&quot;500&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn dispersed-resize &amp;#91;points new-size&amp;#93;
  &amp;#40;let &amp;#91;old-size &amp;#40;count points&amp;#41;
        new-polygon-indices &amp;#40;range 0 old-size &amp;#40;/ old-size new-size&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;mapv #&amp;#40;get points &amp;#40;mod &amp;#40;js/Math.round %&amp;#41; old-size&amp;#41;&amp;#41; 
      new-polygon-indices&amp;#41;&amp;#41;&amp;#41;

&amp;#40;animate &amp;#40;random-polygon 5&amp;#41;
         &amp;#40;random-polygon 13&amp;#41;
         &amp;#40;fixed-interpolation-fn dispersed-resize&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;250&quot; id=&quot;canvas-10&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Much better, the only problem remaining is we are still copying points and not adding new ones. This leads to the visual effect of points growing out of each other. Much nicer would be if the new points were placed somewhere between the old points, somewhere on the edge. Looking at the original function the culprit is using &lt;code&gt;round&lt;/code&gt;. It is throwing away data that could be used. Using the non-integer value to find a new point interpolated between its neighbors should help accomplish this goal.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 11)&quot; data-eval-idle-msec=&quot;500&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn get-interpolated &amp;#91;points index&amp;#93; 
  &amp;#40;interpolate-points &amp;#40;mod index 1&amp;#41; 
    &amp;#40;get points &amp;#40;js/Math.floor index&amp;#41;&amp;#41;
    &amp;#40;get points &amp;#40;mod &amp;#40;js/Math.ceil index&amp;#41; &amp;#40;count points&amp;#41;&amp;#41; 
         &amp;#40;last points&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn resize-polygon &amp;#91;points final-size&amp;#93;
  &amp;#40;let &amp;#91;initial-size &amp;#40;count points&amp;#41;
        initial-indices &amp;#40;range initial-size&amp;#41;
        additional-points &amp;#40;- final-size initial-size&amp;#41;
        new-indices 
        &amp;#40;take additional-points
        &amp;#40;range &amp;#40;/ initial-size final-size&amp;#41; 
               js/Infinity &amp;#40;/ initial-size additional-points&amp;#41;&amp;#41;&amp;#41;&amp;#93;
        &amp;#40;-&amp;gt;&amp;gt; initial-indices
             &amp;#40;concat new-indices&amp;#41;
             &amp;#40;sort&amp;#41;
             &amp;#40;mapv &amp;#40;partial get-interpolated points&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;animate &amp;#40;random-polygon 4&amp;#41;
         &amp;#40;random-polygon 7&amp;#41;
         &amp;#40;fixed-interpolation-fn resize-polygon&amp;#41;&amp;#41;

 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;250&quot; id=&quot;canvas-11&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Looks good! There is definitely more you could do with the algorithm, but for now that's enough. Hope you enjoyed.&lt;/p&gt;&lt;p&gt;&lt;pre style=&quot;display:none&quot;&gt; &lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 0)&quot; data-eval-idle-msec=&quot;500&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;animate &amp;#40;random-polygon 3&amp;#41;
         &amp;#40;random-polygon 5&amp;#41;
         &amp;#40;fixed-interpolation-fn resize-polygon&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;/pre&gt;&lt;/p&gt;&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://app.klipse.tech/css/codemirror.css&quot;&gt;  &lt;/link&gt;&lt;/p&gt;&lt;p&gt;&lt;script&gt; window.klipse_settings = { selector: &quot;.language-klipse&quot; }; &lt;/script&gt; &lt;script src=&quot;http://app.klipse.tech/plugin/js/klipse_plugin.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 21 Feb 2017 00:00:00 -0500
</pubDate>
</item>
<item>
<guid>
http://lambdafunk.com/2017-02-16-Random-Polygons/
</guid>
<link>
http://lambdafunk.com/2017-02-16-Random-Polygons/
</link>
<title>
Random Polygons
</title>
<description>
&lt;p&gt;&lt;strong&gt;Code samples are live and edibtable enabled by &lt;a href='http://github.com/viebel/klipse'&gt;Klipse&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;I was working on another blog post involving polygons and realized how nice it would be to have some random polygons to test with. Turns out its a interesting little problem and now its become a post of its own. &lt;pre style=&quot;display:none&quot;&gt; &lt;div class=&quot;language-klipse&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;def canvas &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;defn get-canvas &amp;#91;id&amp;#93;
  &amp;#40;js/document.getElementById &amp;#40;str &amp;quot;canvas-&amp;quot; @canvas&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn clear-canvas! &amp;#91;canvas-id&amp;#93;
  &amp;#40;let &amp;#91;canvas &amp;#40;get-canvas canvas-id&amp;#41;
        context &amp;#40;.getContext canvas &amp;quot;2d&amp;quot;&amp;#41;&amp;#93;
    &amp;#40;.clearRect context 0 0 &amp;#40;.-width canvas&amp;#41; 
                            &amp;#40;.-height canvas&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn reset-canvas! &amp;#91;canvas-id&amp;#93;
  &amp;#40;reset! canvas canvas-id&amp;#41;
  &amp;#40;clear-canvas! canvas-id&amp;#41;&amp;#41;

&amp;#40;defn render-polygon! 
 &amp;#40;&amp;#91;polygon&amp;#93; &amp;#40;render-polygon! @canvas polygon {}&amp;#41;&amp;#41;
 &amp;#40;&amp;#91;polygon opts&amp;#93; &amp;#40;render-polygon! @canvas polygon opts&amp;#41;&amp;#41;
 &amp;#40;&amp;#91;canvas-id polygon {:keys &amp;#91;color&amp;#93; :or {color &amp;quot;blue&amp;quot;}}&amp;#93;
  &amp;#40;let &amp;#91;canvas &amp;#40;get-canvas canvas-id&amp;#41;
        &amp;#91;&amp;#91;initial-x initial-y&amp;#93; &amp;amp; rest&amp;#93; polygon
        context &amp;#40;.getContext canvas &amp;quot;2d&amp;quot;&amp;#41;&amp;#93;
        &amp;#40;doto context
          &amp;#40;aset &amp;quot;fillStyle&amp;quot; color&amp;#41;
          &amp;#40;.beginPath&amp;#41;
          &amp;#40;.moveTo context initial-x initial-y&amp;#41;&amp;#41;
        &amp;#40;doseq &amp;#91;&amp;#91;x y&amp;#93; rest&amp;#93;
          &amp;#40;.lineTo context x y&amp;#41;&amp;#41;
        &amp;#40;doto context
          &amp;#40;.lineTo initial-x initial-y&amp;#41;
          &amp;#40;.fill&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;/pre&gt; Let's start with generating a regular polygon. This is a perfect problem for polar coordinates. A polygon can be defined as a set of polar points with equal radius and equally divided angles.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn polar-polygon &amp;#91;edges radius&amp;#93;
  &amp;#40;mapv #&amp;#40;vector &amp;#40;&amp;#42; % &amp;#40;/ &amp;#40;&amp;#42; 2 js/Math.PI&amp;#41; edges&amp;#41;&amp;#41; radius&amp;#41;
    &amp;#40;range edges&amp;#41;&amp;#41;&amp;#41;

&amp;#40;polar-polygon 5 70&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;It works, but most graphics programs work with rectangular coordinates. Let's write a quick function to transform polar polygons to rectangular polygons with their center at point &lt;code&gt;&amp;#91;x y&amp;#93;&lt;/code&gt;. &lt;div class=&quot;language-klipse&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn to-rect 
  &amp;#40;&amp;#91;&amp;#91;theta radius&amp;#93;&amp;#93; &amp;#40;to-rect &amp;#91;0 0&amp;#93; &amp;#91;theta radius&amp;#93;&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;&amp;#91;x y&amp;#93; &amp;#91;theta radius&amp;#93;&amp;#93;
    &amp;#91;&amp;#40;+ x &amp;#40;&amp;#42; radius &amp;#40;js/Math.cos theta&amp;#41;&amp;#41;&amp;#41;
     &amp;#40;+ y &amp;#40;&amp;#42; radius &amp;#40;js/Math.sin theta&amp;#41;&amp;#41;&amp;#41;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn regular-polygon 
  &amp;#40;&amp;#91;edges&amp;#93; &amp;#40;regular-polygon edges 100&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;edges radius&amp;#93; &amp;#40;regular-polygon edges &amp;#91;radius radius&amp;#93; radius&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;edges center radius&amp;#93; 
    &amp;#40;mapv &amp;#40;partial to-rect center&amp;#41; &amp;#40;polar-polygon edges radius&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;regular-polygon 5&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt;&lt;/p&gt;&lt;p&gt;And render it.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 4)&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;render-polygon! &amp;#40;regular-polygon 7&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;200&quot; id=&quot;canvas-4&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Or render a few!&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 5)&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;render-polygon! &amp;#40;regular-polygon 9&amp;#41;              {:color &amp;quot;green&amp;quot;}&amp;#41;
&amp;#40;render-polygon! &amp;#40;regular-polygon 5 &amp;#91;260 50&amp;#93;  50&amp;#41; {:color &amp;quot;red&amp;quot;}&amp;#41;
&amp;#40;render-polygon! &amp;#40;regular-polygon 3 &amp;#91;310 130&amp;#93; 40&amp;#41; {:color &amp;quot;blue&amp;quot;}&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;200&quot; id=&quot;canvas-5&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Now to make a random polygon. Take that regular one and add some random noise. We'll modify the original function to add some randomness to the radius and theta. But only enough so the points don't overlap avoiding &lt;a href='https://en.wikipedia.org/wiki/Complex_polygon'&gt;complex&lt;/a&gt; polygons.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 6)&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn random-polar-polygon &amp;#91;edges radius&amp;#93;
  &amp;#40;let &amp;#91;angle-increment &amp;#40;/ &amp;#40;&amp;#42; 2 js/Math.PI&amp;#41; edges&amp;#41;&amp;#93;
    &amp;#40;mapv 
      &amp;#40;fn &amp;#91;edge&amp;#93; 
        &amp;#91;&amp;#40;+ &amp;#40;&amp;#42; angle-increment edge&amp;#41; &amp;#40;&amp;#42; &amp;#40;rand&amp;#41; angle-increment&amp;#41;&amp;#41;
         &amp;#40;&amp;#42; &amp;#40;rand&amp;#41; radius&amp;#41;&amp;#93;&amp;#41;
      &amp;#40;range edges&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn random-polygon 
  &amp;#40;&amp;#91;n&amp;#93; &amp;#40;random-polygon n 100&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;n radius&amp;#93; &amp;#40;random-polygon n &amp;#91;radius radius&amp;#93; radius&amp;#41;&amp;#41;
  &amp;#40;&amp;#91;n center radius&amp;#93; 
    &amp;#40;mapv &amp;#40;partial to-rect center&amp;#41; &amp;#40;random-polar-polygon n radius&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;render-polygon! &amp;#40;random-polygon 9&amp;#41;               {:color &amp;quot;green&amp;quot;}&amp;#41;
&amp;#40;render-polygon! &amp;#40;random-polygon 7  &amp;#91;260 50&amp;#93;  50&amp;#41; {:color &amp;quot;red&amp;quot;}&amp;#41;
&amp;#40;render-polygon! &amp;#40;random-polygon 13 &amp;#91;310 130&amp;#93; 40&amp;#41; {:color &amp;quot;blue&amp;quot;}&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;200&quot; id=&quot;canvas-6&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Hmm... Too pointy. It would be better if the shapes were a little closer to their regular self. Adjusting the distribution and not the range will allow us to continue generating a wide set of polygons, but make it more likely to generate polygons seen in the real world. The &lt;code&gt;pow&lt;/code&gt; function map values &lt;code&gt;&amp;#91;0,1&amp;#93; =&amp;gt; &amp;#91;0,1&amp;#93;&lt;/code&gt; when applied to the uniform random distribution provides a skew. Using this we can skew our random noise to generate a more standard looking set of polygons.&lt;/p&gt;&lt;p&gt;&lt;div class=&quot;language-klipse&quot; data-preamble=&quot;(reset-canvas! 7)&quot;&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn random-polar-polygon &amp;#91;edges radius&amp;#93;
  &amp;#40;let &amp;#91;radius-damper 0.34
        angle-damper  1.22
        angle-increment &amp;#40;/ &amp;#40;&amp;#42; 2 js/Math.PI&amp;#41; edges&amp;#41;&amp;#93;
    &amp;#40;mapv 
      &amp;#40;fn &amp;#91;edge&amp;#93; 
        &amp;#91;&amp;#40;+ &amp;#40;&amp;#42; angle-increment edge&amp;#41; 
            &amp;#40;&amp;#42; &amp;#40;js/Math.pow &amp;#40;rand&amp;#41; angle-damper&amp;#41; angle-increment&amp;#41;&amp;#41;
         &amp;#40;&amp;#42; &amp;#40;js/Math.pow &amp;#40;rand&amp;#41; radius-damper&amp;#41; radius&amp;#41;&amp;#93;&amp;#41;
      &amp;#40;range edges&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;render-polygon! &amp;#40;random-polygon 9&amp;#41;               {:color &amp;quot;green&amp;quot;}&amp;#41;
&amp;#40;render-polygon! &amp;#40;random-polygon 7  &amp;#91;260 50&amp;#93;  50&amp;#41; {:color &amp;quot;red&amp;quot;}&amp;#41;
&amp;#40;render-polygon! &amp;#40;random-polygon 13 &amp;#91;310 130&amp;#93; 40&amp;#41; {:color &amp;quot;blue&amp;quot;}&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; &lt;/div&gt; &lt;canvas width=&quot;400&quot; height=&quot;200&quot; id=&quot;canvas-7&quot;&gt;&lt;/canvas&gt;&lt;/p&gt;&lt;p&gt;Much better. With a little bit of math and we've got some nice looking random polygons.&lt;/p&gt;&lt;p&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://app.klipse.tech/css/codemirror.css&quot;&gt;  &lt;/link&gt;&lt;/p&gt;&lt;p&gt;&lt;script&gt; window.klipse_settings = { selector: &quot;.language-klipse&quot; }; &lt;/script&gt; &lt;script src=&quot;http://app.klipse.tech/plugin/js/klipse_plugin.js&quot;&gt;&lt;/script&gt;&lt;/p&gt;
</description>
<enclosure>

</enclosure>
<pubDate>
Thu, 16 Feb 2017 00:00:00 -0500
</pubDate>
</item>
<item>
<guid>
http://lambdafunk.com/2017-01-31-why-clojure/
</guid>
<link>
http://lambdafunk.com/2017-01-31-why-clojure/
</link>
<title>
Why Clojure?
</title>
<description>
&lt;p&gt;The first half-decade of my programming career I was obsessed with trying new programming languages. I couldn't read a post on Hacker News without taking the language for a spin and building some small test project with it. I wanted desperately to master a programming language, yet every new language seemed so much better than the last one. After the recommendation of a good friend and an incredible &lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy'&gt;presentation&lt;/a&gt; I started using Clojure and I've begun to use it increasingly more. Since then, I've stumbled across and tried some &lt;a href='http://witheve.com'&gt;amazing&lt;/a&gt; &lt;a href='http://elm-lang.org'&gt;programming&lt;/a&gt; &lt;a href='http://haskell.org'&gt;langauges&lt;/a&gt;, but nothing has managed to move my focus away from Clojure. I've written tons of side projects with it, used it professionally for a year and just released a small &lt;a href='https://play.google.com/store/apps/details?id=com.linguis.cards&amp;hl=en'&gt;app&lt;/a&gt; written in it. Clojure grabbed my attention, but unlike many other languages it has continued to do so. Stopping to reflect I noticed, without ever intending to, I have become a Clojure programmer. &quot;Why Clojure?&quot; is not the beginning of a sales pitch, but a question to myself. Why do I enjoy this language so much?&lt;/p&gt;&lt;h2&gt;Realistically Functional&lt;/h2&gt;&lt;p&gt;An important and difficult part of software development is creating consistent software. In Mathematics, functions are pure. A pure function is deterministic which means it is consistent by definition. So if we use values and functions, the problem of consistency disappears. Functional programming takes advantage of this and provides tools for working with concrete immutable values. Fortunately for humanity, and unfortunately for software developers, the world doesn't have a set value, it has state. If our software is going to do something useful, it has to interact with the world. So if our program is going to do something useful, it has to have state.&lt;/p&gt;&lt;p&gt;Object oriented programming does a great job of providing ways to manage this state and this is part of why it has become so popular. Complex object models can be used to represent that state inside of our program. However, with these models of state comes their complexity. Objects tie together behaviors(methods) with state. Connections between things grow at an exponential rate, ala the &lt;a href='http://mathworld.wolfram.com/HandshakeProblem.html'&gt;handshake problem&lt;/a&gt;. The larger the system becomes the more complex it becomes, and each additional relationships adds exponentially more complexity. Anyone who has worked with sufficiently large software has seen this problem first hand. An increasingly complex system becomes increasingly more difficult to understand. The system becomes increasingly more difficult to modify, fix, or imprvome.&lt;/p&gt;&lt;p&gt;In Clojure data is immutable by default, utilizing the purity of stateless functions to avoid the problems of compleity introduced by state.  However, it still acknowledges the benefits and necessity of state by providing well-defined method for handling mutable &lt;a href='https://clojure.org/about/state'&gt;identities&lt;/a&gt;. Providing constructs that make the manipulation of state explicit. As a result, state is something I rarely think about while programming in Clojure, but is readily available when needed. The majority of a Clojure program can be written as functions accepting and returning values. The separation of behavior from state means when working with the logic of a system you do not have to hold the state of that system in your head. When programming a function in Clojure I am only working on the function and the values passed into it. This style of programming took some time to get used to but once I did, it was incredibly freeing. Gone are the days of tracking down bugs caused by some complicated relationship between every changing entities. No more worrying about the effects of simple changes that may ripple through a complicated system.&lt;/p&gt;&lt;h2&gt;A Modern Lisp&lt;/h2&gt;&lt;p&gt;Clojure belongs to a family of languages called &lt;a href='https://en.wikipedia.org/wiki/Lisp_&amp;#40;programming_language&amp;#41;'&gt;Lisp&lt;/a&gt;. Lisp receives a lot of love and hate in the programming community and most of the criticism of Lisp is levied at its syntax. The amount of time we spend reading code as programmers makes syntax an important part of a programming language. Clojure solves some of the problems with traditional Lisp by implementing enough syntactic improvement to make writing and reading Clojure code mode quicker, compared to traditional Lisps. &lt;/p&gt;&lt;p&gt;As a Lisp, Clojure source code is written as a data structure. Traditional Lisps have been designed entirely around the list data structure, providing a very limited syntax for writing code. Clojure has expanded its support for collections, notably: sets, vectors, and maps. Along with providing additional syntax for creating these types. This produces more readable code than previous Lisps, while still providing the property of homoiconicity, which forms the basis of the incredibly powerful macro system in Lisp languages.&lt;/p&gt;&lt;p&gt;Due to Clojure's homoiconicity, or code as data. When writing a macro in Clojure you are writing a function accepting code, and since this code is data, you can treat it the same way you would any other data. This means you have the full power of the language at your disposal. Understanding just how powerful this simple concept is can be difficult without experience. It is often said there is an &lt;a href='http://www.catb.org/esr/faqs/hacker-howto.html'&gt;&quot;aha moment&quot;&lt;/a&gt; when one fully understands the power of Lisp macros. For me, that &quot;aha moment&quot; came with the release of the Clojure core library &lt;a href='https://github.com/clojure/core.async'&gt;core.async&lt;/a&gt;. The core.async library is an implementation of CSP style channels as a core library. Powerful concurrency tools and syntax implemented not as a language feature, but as separate library composed of standard Clojure code. New libraries with features just as powerful are consistently released relying on the power of macros including tools such as &lt;a href='http://github.com/clojure/core.match'&gt;pattern matching&lt;/a&gt;, &lt;a href='http://github.com/clojure/core.logic'&gt;logic programming&lt;/a&gt;, and a &lt;a href='http://github.com/clojure/core.typed'&gt;type system&lt;/a&gt;. Tools like these along with the macros you write in your own code make writing code that is understandable much simpler. &lt;/p&gt;&lt;h2&gt;Excellent Direction&lt;/h2&gt;&lt;p&gt;&lt;a href='https://www.infoq.com/presentations/Simple-Made-Easy'&gt;Simple Made Easy&lt;/a&gt;, the greatest talk I have seen given on programming gives insight into the design process of Clojure as a language. &quot;You can write a sophisticated a system with dramatically simpler tools, which means you're going to be focusing on the system, what it's supposed to do, instead of all the gook that falls out of the constructs you're using.&quot; This quote from the talk highlights the philosophy of Clojure as a language. Programming is about solving difficult problems. Focusing on tools that make something easier, often make the tradeoff of introducing complexity. This complexity grows and grows until we spend more time solving problems created by the complexity than we spend solving the problem itself. Clojure is designed with simplicity as a goal and the more time I spend programming in Clojure the more I realize the value of simplicity. Each feature in Clojure is added to the power of clojure as a tool, while mantaining this clear focus on simplicity.&lt;/p&gt;&lt;p&gt;During its development Clojure has consisntently taken ideas from the development of languages and tools coming before it. Taking a piecemeal approach by borrowing the good parts and leaving the unnecessary behind. Lisp's hygienic macros, running on the JVM, CSP style channels and the latest Clojure feature &lt;a href='https://clojure.org/about/spec'&gt;core.spec&lt;/a&gt;.spec, are all examples of this approach. core.spec is a great example of improving on great ideas of others. It provides a lot of the tools of a type system and is very similar, but is implemented in a way that fits Clojure's simplicity and flexibility as a dynamic language providing validation, error reporting, parsing, instrumentation, documentation, and generative testing. And the language itself is not the only part of Clojure embracing change. The Clojure community itself is frequently tossing out old assumptions about how we should program. Developing libraries with novel and useful approaches to old problems. From &lt;a href='https://github.com/cgrand/enlive'&gt;templating&lt;/a&gt; to &lt;a href='http://swannodette.github.io/2013/12/17/the-future-of-javascript-mvcs'&gt;UI-rendering&lt;/a&gt; Clojure embraces change. Based on a 50 year old language, from the start Clojure has been molded by the tools before, but has shown no sign of clinging to the past.&lt;/p&gt;&lt;h2&gt;Conclusion&lt;/h2&gt;10 years ago, when I started programming, the discussion of programming had more to do with which object system was best. Discussion about language paradigms was something often left to academics. Even startups, moving fast and considered brave, were busy deciding which &lt;a href='http://ruby-lang.org'&gt;dynamic&lt;/a&gt; &lt;a href='http://python.org'&gt;langauge&lt;/a&gt; was more &lt;a href='http://php.net'&gt;hip&lt;/a&gt;. Criticizing object oriented programming was considered brave and talking about functional programming was something unique. So quickly  the discussion has broadened, not just in the Clojure community, but in the programming community at large. People aren't just solving problems, but are thinking deeply about the tools we use to do so. There is a growing trends of not just relying on our tools, but also on our minds. Which leads to the answer for &quot;Why Clojure?&quot;. Because the more I program in Clojure the less time I spend at the keyboard and the more time I spend thinking. With thought as the most powerful tool available, the result is I'm writing better software, but more importantly, I'm having more fun.
</description>
<enclosure>

</enclosure>
<pubDate>
Tue, 31 Jan 2017 00:00:00 -0500
</pubDate>
</item>
</channel>
</rss>
